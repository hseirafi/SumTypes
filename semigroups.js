/** * Created by hoss on 3/2/2016. */const {Map} = require("immutable-ext")// Semigroups are a type with a concat method// in this instance string is the semi group because it has a concat method// when you are able to chain methods  and their type does not change this is called a semigroup// and with concat "closed under concatenation"//const res ='a'.concat('b').concat('c')    // in this instance array is the semigroup    // semigroups comes from abstract algebra//const first =[1,2,3].concat([4,5,6,7]).concat([8,9,10,11])//const concatInner=[1,2,3].concat([4,5,6,7].concat([8,9,10,11]))//const associativity = concatInner;//console.log(associativity);// with associativity order does not mattervar Sum = x=>    ({        x,        concat: ({x:y}) =>        Sum(x + y ),         inspect:() =>         `Sum(${x})`    })//// const res = Sum(1).concat(Sum(2))//// console.log(res);//true && false // false//true && true // true    //instead of addition we conjunction "&&"var All = x =>    ({        x,        concat: ({x:y}) =>            All(x && y ),        inspect:() =>            `All(${x})`    })//const res = All(true).concat(All(true)) // All(false)//console.log(res);const First = x =>    ({        x,        concat: _ =>            First(x ),        inspect:() =>            `First(${x})`    })//const res = First("blah").concat(First("ice cream")).concat(First('meta Programming'))//console.log(res)// when combining two thing one should think of semi groups.// If a data structure is made of semi groups it will be a semi group itself// if you can concat all the peaces of your data structure than your structure is concatableconst acct1 = Map({name: First('Nico'), isPaid:All(true),    points:Sum(10), friends:['Franklin']})const acct2 =  Map({ name: First('Nico'), isPaid:All(false),    points:Sum(2), friends:['Gatsby']})// const res = acct1.concat(acct2)// console.log(res.toJSON());// 0 plus that thing returns that thing// this property is called a monoid// 1+0 //1// 2+0 //2// x+0 //x// if there is a special element like 0 under addition we have monoid// it is a semi-group with a special element that acts like a neutral identity// defining the interfacevar Sum = x=>    ({        x,        concat: ({x:y}) =>            Sum(x + y ),        inspect:() =>            `Sum(${x})`    })// sum is a monoid if it has a concat method as a semi-group// and has an empty function that returns the special typeSum.empty = () => Sum(0); //const res = Sum.empty().concat(Sum(1).concat(Sum(2)))//console.log(res)var All = x =>    ({        x,        concat: ({x:y}) =>            All(x && y ),        inspect:() =>            `All(${x})`    })All.empty= () => All(true)// true is neutral because in conjunction true is default// unless combined with false// true && true = true// false && true = false// true && false = false//const res = All(false).concat(All(true)).concat(All.empty())  // All(false)//console.log(res) // All(false)const First = x =>    ({        x,        concat: _ =>            First(x ),        inspect:() =>            `First(${x})`    })// First semi-group cannot be changed to a monoid// because there is no way to define a natural elementconst sum = xs =>xs.reduce((acc,x)=> acc+x,0 )sum([1,2,3])//6sum([]) // 0const all = xs =>    xs.reduce((acc,x)=> acc && x, true)const first = xs =>    xs.reduce((acc,x)=> acc )first([1,2,3]) // 1first([])// fail because no value to return// monoid are safe operation while semi-groups are not// because monoid's will always return a value while semi-groups might not